                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 29 octobre 2021, 23h59

## Identité

Nombre de binôme: 12
Nom, prénom 1: AL AZAWI Rayan
Nom, prénom 2: SIMONEAU Louis-Alexei

## Questions sur votre code

0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

Oui. Make s'éxécute sans erreurs ou warnings, et ./dpll sudoku-4x4.cnf donne la réponse attendue.

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ?
    - Si oui, expliquez en quelques phrases en français comment vous
      l'avez utilisée.
    - Si non, expliquez en quelques phrases en français comment
      fonctionne votre implémentation de `simplifie`.

Oui. Filter_map à été utilisé pour simplifier la liste clauses et les sous listes dans clauses:

    -Si une des sous listes contient le littéral i, on la supprime en renvoyant None.

    (En effet, si un littéral est vrai dans une clause CNF, alors il n'y a plus lieu de la prendre en compte - car elle est composée uniquement de OU logiques)

    Exemple : Soit la clause (A v B v -C). Mettons A = True. Alors, quelque soient les interprétations de B et de C, (A v B v -C) est valide. La clause peut donc être retirée

    -Si une des sous listes est vide, on peut la retirer.

    -Si le litéral -i existe dans une des sous-listes, avec i étant vrai, on peut le retirer. Cette fonctionnalité à été implémentée en utilisant un autre filter_map dans chaque sous liste.

    (En effet, si i est vrai, -i est faux, et n'aura donc aucun impact sur une clause CNF - car elle est composée uniquement de OU logiques)

    Exemple : Soit la clause (A v B v -C). Mettons C = True. Alors, quelque soient les interprétations de A et de B, A v B v -C <=> A v B

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

Nous avons utilisé des fonctions auxiliaires pour la fonction unitaire :

    -List.length : Il y a une méthode très simple pour identifier les clauses unitaires - la taille de la liste la contenant est toujours 1 !
    Ainsi, on itère sur toutes les sous listes de la liste 'clauses'. Si une des sous listes est de List.length exactement 1, alors on renvoie l'élément contenu.

    -List.hd : Dès qu'on trouve une clause unitaire, on renvoie donc son premier et unique élément. List.hd permet de le récupérer et de le renvoyer.

---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

Nous avons utilisé des fonctions auxiliaires pour la fonction pur :

    -List.flatten : Pour simplifier l'implémentation de la fonction pur, nous avons applati toutes les sous listes de 'clauses' en une seule liste avec List.flatten.

    -function aux original acc : fonction que nous avons écrite contenant un accumulateur et la liste originale pour permettre la récursivité terminale de pur. Fonction interne à pur.

    -List.mem : dès qu'on a une liste applatie de tous les littéraux, il suffit de vérifier, pour tout littéral i, si son opposé -i existe dans la liste. Si il n'existe pas, alors il est pur. List.mem permet de vérifier si une valeur est dans une liste.

---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

Pour l'exemple_7_2 = [ [ 1; -1; -3 ]; [ -2; 3 ]; [ -2 ] ] :

    I/ Clauses unitaires
    -solveur_split ne va pas reconnaitre la clause unitaire [ -2 ]

    --solveur_dpll_rec reconnaitra la clause unitaire [ -2 ], et simplifiera la liste (simplifie -2):
    [ [ 1; -1; -3 ]; [ -2; 3 ]; [ -2 ] ] ==> [ [ 1; -1; -3 ] ]

    II/ Littéraux purs
    -solveur_split ne va pas reconnaitre le littéral pur -2.

    -solveur_dpll_rec reconnaitra le littéral pur -2, et simplifiera la liste (simplifie -2):
    [ [ 1; -1; -3 ]; [ -2; 3 ]; [ -2 ] ] ==> [ [ 1; -1; -3 ] ]

De I et II on conclut que les différences entre ces deux fonctions sont :

    -L'identification et la simplification des clauses unitaires

    -L'identification et la simplification des littéraux purs

Et cela à pour effet d'implémenter un vrai algorithme DPLL dans la fonction solveur_dpll_rec

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

BENCHMARKS

$ time ./dpll sudoku-9x9-god.cnf  
SAT

0.65s user 0.14s system 99% cpu 0.787 total

Nous avons aussi implémenté deux fonctions utilitaires permettant le debugging du programme si besoin :

    -function printList l : Prend une liste de int en argument et affiche la liste sur le terminal.

    printList [ [ 1; -2; 3 ] ] affichera sur le terminal :

    1 -2 3

    -function printLList l : Prend une liste de liste de int en argument et affiche la liste sur le terminal.

    printLList [ [ 1; -2; 3 ]; [ 1; -3 ]; [ 2; 3 ]; [ 1; -2 ] ] affichera sur le terminal :

    1 -2 3
    1 -3
    2 3
    1 -2

---

--fin du fichier RENDU--
